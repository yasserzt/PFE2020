{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 1159f805e024a6120bc9","webpack:///./src/utils.js","webpack:///./src/exceptions.js","webpack:///./src/flush.js","webpack:///./src/promise.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isPromise","item","Promise","window","Window","constructor","toString","then","err","dispatchedErrors","possiblyUnhandledPromiseHandlers","activeCount","flushPromise","flushActive","promise","resolve","startActive","endActive","ZalgoPromise","handler","_this","_classCallCheck","resolved","rejected","errorHandled","handlers","result","error","isAsync","res","reject","Error","value","dispatch","_this2","setTimeout","indexOf","push","j","length","dispatchPossiblyUnhandledError","asyncReject","dispatching","chain","firstPromise","secondPromise","_handlers$i","onSuccess","onError","undefined","onFinally","timeout","time","_this3","clearTimeout","toPromise","TypeError","all","promises","count","results","prom","hash","keys","map","key","items","method","onPossiblyUnhandledException","cancel","splice","context","args","apply","delay","flush","__webpack_exports__","promise_ZalgoPromise"],"mappings":"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","file":"zalgo-promise.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ZalgoPromise\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZalgoPromise\"] = factory();\n\telse\n\t\troot[\"ZalgoPromise\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1159f805e024a6120bc9","/* @flow */\n\nexport function isPromise(item : mixed) : boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.Window === 'function' && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.constructor === 'function' && item instanceof window.constructor) {\n            return false;\n        }\n\n        let toString = ({}).toString;\n\n        if (toString) {\n            let name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nconst dispatchedErrors = [];\nconst possiblyUnhandledPromiseHandlers : Array<(mixed, promise? : ZalgoPromise<mixed>) => void> = [];\n\nexport function dispatchPossiblyUnhandledError<T>(err : mixed, promise : ZalgoPromise<T>) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(`${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${ promise.stack }`);\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        // $FlowFixMe\n        possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler : (mixed, promise? : ZalgoPromise<mixed>) => void) : { cancel : () => void } {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/exceptions.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nlet activeCount = 0;\nlet flushPromise;\n\nfunction flushActive() {\n    if (!activeCount && flushPromise) {\n        const promise = flushPromise;\n        flushPromise = null;\n        promise.resolve();\n    }\n}\n\nexport function startActive() {\n    activeCount += 1;\n}\n\nexport function endActive() {\n    activeCount -= 1;\n    flushActive();\n}\n\nexport function awaitActive(Zalgo : Class<ZalgoPromise<*>>) : ZalgoPromise<void> { // eslint-disable-line no-undef\n    let promise = flushPromise = flushPromise || new Zalgo();\n    flushActive();\n    return promise;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/flush.js","/* @flow */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { startActive, endActive, awaitActive } from './flush';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean\n    rejected : boolean\n    errorHandled : boolean\n    value : R\n    error : mixed\n    handlers : Array<{\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    }>\n    dispatching : boolean\n    stack : string\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            startActive();\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                endActive();\n                this.reject(err);\n                return;\n            }\n\n            endActive();\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            // $FlowFixMe\n            let err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${ err }`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) : ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n    \n    dispatch() {\n\n        let { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        startActive();\n\n        const chain = <T>(firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                secondPromise.resolve(res);\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            let { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    chain(result, promise);\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        endActive();\n    }\n\n    then<X : mixed, Y : mixed>(onSuccess : void | (result : R) => (ZalgoPromise<X> | Y), onError : void | (error : mixed) => (ZalgoPromise<X> | Y)) : ZalgoPromise<X | Y> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        let promise : ZalgoPromise<X | Y> = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X : mixed, Y : mixed>(onError : (error : mixed) => ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n        return this.then(undefined, onError);\n    }\n\n    finally(onFinally : () => mixed) : ZalgoPromise<R> {\n\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        return this.then((result) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        let timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    static resolve<X : mixed>(value : X | ZalgoPromise<X>) : ZalgoPromise<X> {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X : Array<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n\n        let promise = new ZalgoPromise();\n        let count = promises.length;\n        let results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        const chain = <T>(i : number, firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                results[i] = res;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < promises.length; i++) {\n            let prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            chain(i, ZalgoPromise.resolve(prom), promise);\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O : Object>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n        let result = {};\n        \n        return ZalgoPromise.all(Object.keys(promises).map(key => {\n            return ZalgoPromise.resolve(promises[key]).then(value => {\n                result[key] = value;\n            });\n        })).then(() => {\n            return result;\n        });\n    }\n\n    static map<T, X>(items : Array<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<Array<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => void) : { cancel : () => void } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X : mixed, Y : mixed, C : mixed, A : Array<mixed>>(method : (...args : A) => (ZalgoPromise<X> | Y), context : ?C, args : ?A) : ZalgoPromise<X | Y> {\n\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result;\n\n        startActive();\n        \n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            endActive();\n            return ZalgoPromise.reject(err);\n        }\n\n        endActive();\n\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        return awaitActive(ZalgoPromise);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/promise.js","/* @flow */\n\nexport { ZalgoPromise } from './promise';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}