{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e2e930b4c317fcb3f627","webpack:///./src/utils.js","webpack:///./src/exceptions.js","webpack:///./src/flush.js","webpack:///./src/promise.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isPromise","item","Promise","window","Window","constructor","toString","then","err","dispatchedErrors","possiblyUnhandledPromiseHandlers","activeCount","flushPromise","flushActive","promise","resolve","startActive","endActive","ZalgoPromise","handler","_this","_classCallCheck","resolved","rejected","errorHandled","handlers","result","error","isAsync","res","reject","Error","value","dispatch","_this2","setTimeout","indexOf","push","j","length","dispatchPossiblyUnhandledError","asyncReject","dispatching","chain","firstPromise","secondPromise","_handlers$i","onSuccess","onError","undefined","onFinally","timeout","time","_this3","clearTimeout","toPromise","TypeError","all","promises","count","results","prom","hash","keys","map","key","items","method","onPossiblyUnhandledException","cancel","splice","context","args","apply","delay","flush","Zalgo","awaitActive","__webpack_exports__","promise_ZalgoPromise"],"mappings":"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","file":"zalgo-promise.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ZalgoPromise\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZalgoPromise\"] = factory();\n\telse\n\t\troot[\"ZalgoPromise\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e2e930b4c317fcb3f627","/* @flow */\n\nexport function isPromise(item : mixed) : boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.Window === 'function' && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.constructor === 'function' && item instanceof window.constructor) {\n            return false;\n        }\n\n        let toString = ({}).toString;\n\n        if (toString) {\n            let name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nconst dispatchedErrors = [];\nconst possiblyUnhandledPromiseHandlers : Array<(mixed, promise? : ZalgoPromise<mixed>) => void> = [];\n\nexport function dispatchPossiblyUnhandledError<T>(err : mixed, promise : ZalgoPromise<T>) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(`${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${ promise.stack }`);\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        // $FlowFixMe\n        possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler : (mixed, promise? : ZalgoPromise<mixed>) => void) : { cancel : () => void } {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/exceptions.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nlet activeCount = 0;\nlet flushPromise;\n\nfunction flushActive() {\n    if (!activeCount && flushPromise) {\n        const promise = flushPromise;\n        flushPromise = null;\n        promise.resolve();\n    }\n}\n\nexport function startActive() {\n    activeCount += 1;\n}\n\nexport function endActive() {\n    activeCount -= 1;\n    flushActive();\n}\n\nexport function awaitActive(Zalgo : Class<ZalgoPromise<*>>) : ZalgoPromise<void> { // eslint-disable-line no-undef\n    let promise = flushPromise = flushPromise || new Zalgo();\n    flushActive();\n    return promise;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/flush.js","/* @flow */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { startActive, endActive, awaitActive } from './flush';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean\n    rejected : boolean\n    errorHandled : boolean\n    value : R\n    error : mixed\n    handlers : Array<{\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    }>\n    dispatching : boolean\n    stack : string\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            startActive();\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                endActive();\n                this.reject(err);\n                return;\n            }\n\n            endActive();\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            // $FlowFixMe\n            let err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${ err }`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) : ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n    \n    dispatch() {\n\n        let { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        startActive();\n\n        const chain = <T>(firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                secondPromise.resolve(res);\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            let { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    chain(result, promise);\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        endActive();\n    }\n\n    then<X : mixed, Y : mixed>(onSuccess : void | (result : R) => (ZalgoPromise<X> | Y), onError : void | (error : mixed) => (ZalgoPromise<X> | Y)) : ZalgoPromise<X | Y> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        let promise : ZalgoPromise<X | Y> = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X : mixed, Y : mixed>(onError : (error : mixed) => ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n        return this.then(undefined, onError);\n    }\n\n    finally(onFinally : () => mixed) : ZalgoPromise<R> {\n\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        return this.then((result) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        let timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    static resolve<X : mixed>(value : X | ZalgoPromise<X>) : ZalgoPromise<X> {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X : Array<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n\n        let promise = new ZalgoPromise();\n        let count = promises.length;\n        let results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        const chain = <T>(i : number, firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                results[i] = res;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < promises.length; i++) {\n            let prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            chain(i, ZalgoPromise.resolve(prom), promise);\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O : Object>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n        let result = {};\n        \n        return ZalgoPromise.all(Object.keys(promises).map(key => {\n            return ZalgoPromise.resolve(promises[key]).then(value => {\n                result[key] = value;\n            });\n        })).then(() => {\n            return result;\n        });\n    }\n\n    static map<T, X>(items : Array<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<Array<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => void) : { cancel : () => void } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X : mixed, Y : mixed, C : mixed, A : Array<mixed>>(method : (...args : A) => (ZalgoPromise<X> | Y), context : ?C, args : ?A) : ZalgoPromise<X | Y> {\n\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result;\n\n        startActive();\n        \n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            endActive();\n            return ZalgoPromise.reject(err);\n        }\n\n        endActive();\n\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        return awaitActive(ZalgoPromise);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/promise.js","/* @flow */\n\nexport { ZalgoPromise } from './promise';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}