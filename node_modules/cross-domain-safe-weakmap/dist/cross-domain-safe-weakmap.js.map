{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 20f70888d3d37841d8aa","webpack:///./node_modules/cross-domain-utils/src/constants.js","webpack:///./node_modules/cross-domain-utils/src/utils.js","webpack:///./src/util.js","webpack:///./src/weakmap.js","webpack:///./src/native.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","PROTOCOL","MOCK","FILE","ABOUT","IE_WIN_ACCESS_ERROR","isAboutProtocol","arguments","length","undefined","window","location","protocol","canReadFromWindow","win","href","err","getActualDomain","Error","parent","getParent","host","getDomain","domain","mockDomain","indexOf","iframeWindows","iframeFrames","isWindowClosed","allowMock","closed","message","desc","getOwnPropertyDescriptor","isActuallySameDomain","isSameDomain","mockclosed","top","iframeIndex","collection","item","safeIndexOf","frame","contentWindow","parentNode","doc","ownerDocument","documentElement","contains","isFrameWindowClosed","isWindow","obj","toString","Window","__cross_domain_utils_window_check__","CrossDomainSafeWeakMap","_classCallCheck","Math","random","WeakMap","freeze","testWeakMap","testKey","set","hasNativeWeakMap","weakmap","keys","values","_cleanupClosedWindows","value","splice","isSafeToReadWrite","key","entry","writable","index","push","has","getOrSet","__webpack_exports__","weakmap_CrossDomainSafeWeakMap"],"mappings":"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","file":"cross-domain-safe-weakmap.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"xdsweakmap\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"xdsweakmap\"] = factory();\n\telse\n\t\troot[\"xdsweakmap\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 20f70888d3d37841d8aa","/* @flow */\n\nexport const PROTOCOL = {\n    MOCK:  ('mock:' : 'mock:'),\n    FILE:  ('file:' : 'file:'),\n    ABOUT: ('about:' : 'about:')\n};\n\nexport const WILDCARD = '*';\n\nexport const WINDOW_TYPE = {\n    IFRAME: ('iframe' : 'iframe'),\n    POPUP:  ('popup' : 'popup')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/constants.js","/* @flow */\n/* eslint max-lines: 0 */\n\nimport { isRegex, noop } from './util';\nimport type { CrossDomainWindowType, SameDomainWindowType, DomainMatcher } from './types';\nimport { PROTOCOL, WILDCARD } from './constants';\n\nlet IE_WIN_ACCESS_ERROR = 'Call was rejected by callee.\\r\\n';\n\nexport function isFileProtocol(win : SameDomainWindowType = window) : boolean {\n    return win.location.protocol === PROTOCOL.FILE;\n}\n\nexport function isAboutProtocol(win : SameDomainWindowType = window) : boolean {\n    return win.location.protocol === PROTOCOL.ABOUT;\n}\n\nexport function getParent(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n\n    if (!win) {\n        return;\n    }\n\n    try {\n        if (win.parent && win.parent !== win) {\n            return win.parent;\n        }\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function getOpener(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n\n    if (!win) {\n        return;\n    }\n\n    // Make sure we're not actually an iframe which has had window.open() called on us\n    if (getParent(win)) {\n        return;\n    }\n\n    try {\n        return win.opener;\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function canReadFromWindow(win : CrossDomainWindowType | SameDomainWindowType) : boolean {\n    try {\n        // $FlowFixMe\n        noop(win && win.location && win.location.href);\n        return true;\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function getActualDomain(win? : SameDomainWindowType = window) : string {\n\n    let location = win.location;\n\n    if (!location) {\n        throw new Error(`Can not read window location`);\n    }\n\n    let protocol = location.protocol;\n\n    if (!protocol) {\n        throw new Error(`Can not read window protocol`);\n    }\n\n    if (protocol === PROTOCOL.FILE) {\n        return `${ PROTOCOL.FILE }//`;\n    }\n\n    if (protocol === PROTOCOL.ABOUT) {\n\n        let parent = getParent(win);\n        if (parent && canReadFromWindow(parent)) {\n            // $FlowFixMe\n            return getActualDomain(parent);\n        }\n\n        return `${ PROTOCOL.ABOUT }//`;\n    }\n\n    let host = location.host;\n\n    if (!host) {\n        throw new Error(`Can not read window host`);\n    }\n\n    return `${ protocol }//${ host }`;\n}\n\nexport function getDomain(win? : SameDomainWindowType = window) : string {\n\n    let domain = getActualDomain(win);\n\n    if (domain && win.mockDomain && win.mockDomain.indexOf(PROTOCOL.MOCK) === 0) {\n        return win.mockDomain;\n    }\n\n    return domain;\n}\n\nexport function isBlankDomain(win : CrossDomainWindowType) : boolean {\n    try {\n        // $FlowFixMe\n        if (!win.location.href) {\n            return true;\n        }\n\n        if (win.location.href === 'about:blank') {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function isActuallySameDomain(win : CrossDomainWindowType) : boolean {\n\n    try {\n        if (win === window) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        let desc = Object.getOwnPropertyDescriptor(win, 'location');\n\n        if (desc && desc.enumerable === false) {\n            return false;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        // $FlowFixMe\n        if (isAboutProtocol(win) && canReadFromWindow(win)) {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        // $FlowFixMe\n        if (getActualDomain(win) === getActualDomain(window)) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function isSameDomain(win : CrossDomainWindowType | SameDomainWindowType) : boolean {\n\n    if (!isActuallySameDomain(win)) {\n        return false;\n    }\n\n    try {\n\n        if (win === window) {\n            return true;\n        }\n\n        // $FlowFixMe\n        if (isAboutProtocol(win) && canReadFromWindow(win)) {\n            return true;\n        }\n\n        // $FlowFixMe\n        if (getDomain(window) === getDomain(win)) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\n\nexport function assertSameDomain(win : CrossDomainWindowType | SameDomainWindowType) : SameDomainWindowType {\n    if (!isSameDomain(win)) {\n        throw new Error(`Expected window to be same domain`);\n    }\n\n    // $FlowFixMe\n    return win;\n}\n\nexport function getParents(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    try {\n\n        while (win.parent !== win) {\n            result.push(win.parent);\n            win = win.parent;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return result;\n}\n\nexport function isAncestorParent(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    if (!parent || !child) {\n        return false;\n    }\n\n    let childParent = getParent(child);\n\n    if (childParent) {\n        return childParent === parent;\n    }\n\n    if (getParents(child).indexOf(parent) !== -1) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function getFrames(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    let frames;\n\n    try {\n        frames = win.frames;\n    } catch (err) {\n        frames = win;\n    }\n\n    let len;\n\n    try {\n        len = frames.length;\n    } catch (err) {\n        // pass\n    }\n\n    if (len === 0) {\n        return result;\n    }\n\n    if (len) {\n        for (let i = 0; i < len; i++) {\n\n            let frame;\n\n            try {\n                frame = frames[i];\n            } catch (err) {\n                continue;\n            }\n\n            result.push(frame);\n        }\n\n        return result;\n    }\n\n    for (let i = 0; i < 100; i++) {\n        let frame;\n\n        try {\n            frame = frames[i];\n        } catch (err) {\n            return result;\n        }\n\n        if (!frame) {\n            return result;\n        }\n\n        result.push(frame);\n    }\n\n    return result;\n}\n\n\nexport function getAllChildFrames(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    for (let frame of getFrames(win)) {\n        result.push(frame);\n\n        for (let childFrame of getAllChildFrames(frame)) {\n            result.push(childFrame);\n        }\n    }\n\n    return result;\n}\n\nexport function getTop(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n\n    try {\n        if (win.top) {\n            return win.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    if (getParent(win) === win) {\n        return win;\n    }\n\n    try {\n        if (isAncestorParent(window, win) && window.top) {\n            return window.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        if (isAncestorParent(win, window) && window.top) {\n            return window.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    for (let frame of getAllChildFrames(win)) {\n        try {\n            if (frame.top) {\n                return frame.top;\n            }\n        } catch (err) {\n            // pass\n        }\n\n        if (getParent(frame) === frame) {\n            return frame;\n        }\n    }\n}\n\nexport function getNextOpener(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n    return getOpener(getTop(win) || win);\n}\n\nexport function getUltimateTop(win? : CrossDomainWindowType = window) : CrossDomainWindowType {\n    let opener = getNextOpener(win);\n\n    if (opener) {\n        return getUltimateTop(opener);\n    }\n\n    return top;\n}\n\nexport function getAllFramesInWindow(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n    let top = getTop(win);\n\n    if (!top) {\n        throw new Error(`Can not determine top window`);\n    }\n\n    return [ ...getAllChildFrames(top), top ];\n}\n\nexport function getAllWindows(win? : CrossDomainWindowType = window) : $ReadOnlyArray<CrossDomainWindowType> {\n    let frames = getAllFramesInWindow(win);\n    let opener = getNextOpener(win);\n\n    if (opener) {\n        return [ ...getAllWindows(opener), ...frames ];\n    } else {\n        return frames;\n    }\n}\n\nexport function isTop(win : CrossDomainWindowType) : boolean {\n    return win === getTop(win);\n}\n\nexport function isFrameWindowClosed(frame : HTMLIFrameElement) : boolean {\n\n    if (!frame.contentWindow) {\n        return true;\n    }\n\n    if (!frame.parentNode) {\n        return true;\n    }\n\n    let doc = frame.ownerDocument;\n\n    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction safeIndexOf<T>(collection : Array<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\nlet iframeWindows = [];\nlet iframeFrames = [];\n\nexport function isWindowClosed(win : CrossDomainWindowType, allowMock : boolean = true) : boolean {\n\n    try {\n        if (win === window) {\n            return false;\n        }\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        if (!win) {\n            return true;\n        }\n\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        if (win.closed) {\n            return true;\n        }\n\n    } catch (err) {\n\n        // I love you so much IE\n\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return false;\n        }\n\n        return true;\n    }\n\n\n    if (allowMock && isSameDomain(win)) {\n        try {\n            // $FlowFixMe\n            if (win.mockclosed) {\n                return true;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    // Mobile safari\n\n    try {\n        if (!win.parent || !win.top) {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    // Yes, this actually happens in IE. win === win errors out when the window\n    // is from an iframe, and the iframe was removed from the page.\n\n    try {\n        noop(win === win); // eslint-disable-line no-self-compare\n    } catch (err) {\n        return true;\n    }\n\n    // IE orphaned frame\n\n    let iframeIndex = safeIndexOf(iframeWindows, win);\n\n    if (iframeIndex !== -1) {\n        let frame = iframeFrames[iframeIndex];\n\n        if (frame && isFrameWindowClosed(frame)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction cleanIframes() {\n    for (let i = 0; i < iframeWindows.length; i++) {\n        let closed = false;\n\n        try {\n            closed = iframeWindows[i].closed;\n        } catch (err) {\n            // pass\n        }\n\n        if (closed) {\n            iframeFrames.splice(i, 1);\n            iframeWindows.splice(i, 1);\n        }\n    }\n}\n\nexport function linkFrameWindow(frame : HTMLIFrameElement) {\n\n    cleanIframes();\n\n    if (frame && frame.contentWindow) {\n        try {\n            iframeWindows.push(frame.contentWindow);\n            iframeFrames.push(frame);\n        } catch (err) {\n            // pass\n        }\n    }\n}\n\nexport function getUserAgent(win : ?SameDomainWindowType) : string {\n    win = win || window;\n    return win.navigator.mockUserAgent || win.navigator.userAgent;\n}\n\n\nexport function getFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let winFrames = getFrames(win);\n\n    for (let childFrame of winFrames) {\n        try {\n            // $FlowFixMe\n            if (isSameDomain(childFrame) && childFrame.name === name && winFrames.indexOf(childFrame) !== -1) {\n                return childFrame;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    try {\n        // $FlowFixMe\n        if (winFrames.indexOf(win.frames[name]) !== -1) {\n            // $FlowFixMe\n            return win.frames[name];\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        if (winFrames.indexOf(win[name]) !== -1) {\n            return win[name];\n        }\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function findChildFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let frame = getFrameByName(win, name);\n\n    if (frame) {\n        return frame;\n    }\n\n    for (let childFrame of getFrames(win)) {\n        let namedFrame = findChildFrameByName(childFrame, name);\n\n        if (namedFrame) {\n            return namedFrame;\n        }\n    }\n}\n\nexport function findFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let frame;\n\n    frame = getFrameByName(win, name);\n\n    if (frame) {\n        return frame;\n    }\n\n    let top = getTop(win) || win;\n\n    return findChildFrameByName(top, name);\n}\n\nexport function isParent(win : CrossDomainWindowType, frame : CrossDomainWindowType) : boolean {\n\n    let frameParent = getParent(frame);\n\n    if (frameParent) {\n        return frameParent === win;\n    }\n\n    for (let childFrame of getFrames(win)) {\n        if (childFrame === frame) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function isOpener(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    return parent === getOpener(child);\n}\n\nexport function getAncestor(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n    win = win || window;\n\n    let opener = getOpener(win);\n\n    if (opener) {\n        return opener;\n    }\n\n    let parent = getParent(win);\n\n    if (parent) {\n        return parent;\n    }\n}\n\nexport function getAncestors(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let results = [];\n\n    let ancestor = win;\n\n    while (ancestor) {\n        ancestor = getAncestor(ancestor);\n        if (ancestor) {\n            results.push(ancestor);\n        }\n    }\n\n    return results;\n}\n\n\nexport function isAncestor(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    let actualParent = getAncestor(child);\n\n    if (actualParent) {\n        if (actualParent === parent) {\n            return true;\n        }\n\n        return false;\n    }\n\n    if (child === parent) {\n        return false;\n    }\n\n    if (getTop(child) === child) {\n        return false;\n    }\n\n    for (let frame of getFrames(parent)) {\n        if (frame === child) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function isPopup(win? : CrossDomainWindowType = window) : boolean {\n    return Boolean(getOpener(win));\n}\n\nexport function isIframe(win? : CrossDomainWindowType = window) : boolean {\n    return Boolean(getParent(win));\n}\n\nexport function isFullpage(win? : CrossDomainWindowType = window) : boolean {\n    return Boolean(!isIframe(win) && !isPopup(win));\n}\n\nfunction anyMatch(collection1, collection2) : boolean {\n\n    for (let item1 of collection1) {\n        for (let item2 of collection2) {\n            if (item1 === item2) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nexport function getDistanceFromTop(win : CrossDomainWindowType = window) : number {\n    let distance = 0;\n    let parent = win;\n\n    while (parent) {\n        parent = getParent(parent);\n        if (parent) {\n            distance += 1;\n        }\n    }\n\n    return distance;\n}\n\nexport function getNthParent(win : CrossDomainWindowType, n : number = 1) : ?CrossDomainWindowType {\n    let parent = win;\n\n    for (let i = 0; i < n; i++) {\n        if (!parent) {\n            return;\n        }\n\n        parent = getParent(parent);\n    }\n\n    return parent;\n}\n\nexport function getNthParentFromTop(win : CrossDomainWindowType, n : number = 1) : ?CrossDomainWindowType {\n    return getNthParent(win, getDistanceFromTop(win) - n);\n}\n\nexport function isSameTopWindow(win1 : CrossDomainWindowType, win2 : CrossDomainWindowType) : boolean {\n\n    let top1 = getTop(win1) || win1;\n    let top2 = getTop(win2) || win2;\n\n    try {\n        if (top1 && top2) {\n            if (top1 === top2) {\n                return true;\n            }\n\n            return false;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    let allFrames1 = getAllFramesInWindow(win1);\n    let allFrames2 = getAllFramesInWindow(win2);\n\n    if (anyMatch(allFrames1, allFrames2)) {\n        return true;\n    }\n\n    let opener1 = getOpener(top1);\n    let opener2 = getOpener(top2);\n\n    if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) {\n        return false;\n    }\n\n    if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) {\n        return false;\n    }\n\n    return false;\n}\n\nexport function matchDomain(pattern : DomainMatcher, origin : DomainMatcher) : boolean {\n\n    if (typeof pattern === 'string') {\n\n        if (typeof origin === 'string') {\n            return pattern === WILDCARD || origin === pattern;\n        }\n\n        if (isRegex(origin)) {\n            return false;\n        }\n\n        if (Array.isArray(origin)) {\n            return false;\n        }\n    }\n\n    if (isRegex(pattern)) {\n\n        if (isRegex(origin)) {\n            return pattern.toString() === origin.toString();\n        }\n\n        if (Array.isArray(origin)) {\n            return false;\n        }\n\n        // $FlowFixMe\n        return Boolean(origin.match(pattern));\n    }\n\n    if (Array.isArray(pattern)) {\n\n        if (Array.isArray(origin)) {\n            return JSON.stringify(pattern) === JSON.stringify(origin);\n        }\n\n        if (isRegex(origin)) {\n            return false;\n        }\n\n        return pattern.some(subpattern => matchDomain(subpattern, origin));\n    }\n\n    return false;\n}\n\nexport function stringifyDomainPattern(pattern : DomainMatcher) : string {\n    if (Array.isArray(pattern)) {\n        return `(${ pattern.join(' | ') })`;\n    } else if (isRegex(pattern)) {\n        return `RegExp(${ pattern.toString() }`;\n    } else {\n        return pattern.toString();\n    }\n}\n\nexport function getDomainFromUrl(url : string) : string {\n\n    let domain;\n\n    if (url.match(/^(https?|mock|file):\\/\\//)) {\n        domain = url;\n    } else {\n        return getDomain();\n    }\n\n    domain = domain.split('/').slice(0, 3).join('/');\n\n    return domain;\n}\n\nexport function onCloseWindow(win : CrossDomainWindowType, callback : Function, delay : number = 1000, maxtime : number = Infinity) : { cancel : () => void } {\n\n    let timeout;\n\n    let check = () => {\n\n        if (isWindowClosed(win)) {\n\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n\n            return callback();\n        }\n\n        if (maxtime <= 0) {\n            clearTimeout(timeout);\n        } else {\n            maxtime -= delay;\n            timeout = setTimeout(check, delay);\n        }\n    };\n\n    check();\n\n    return {\n        cancel() {\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n        }\n    };\n}\n\n// eslint-disable-next-line complexity\nexport function isWindow(obj : Object) : boolean {\n\n    try {\n        if (obj === window) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (Object.prototype.toString.call(obj) === '[object Window]') {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (window.Window && obj instanceof window.Window) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.self === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.parent === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.top === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (noop(obj === obj) === '__unlikely_value__') { // eslint-disable-line no-self-compare\n            return false;\n        }\n\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        if (obj && obj.__cross_domain_utils_window_check__ === '__unlikely_value__') {\n            return false;\n        }\n\n    } catch (err) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function isBrowser() : boolean {\n    return (typeof window !== 'undefined' && typeof window.location !== 'undefined');\n}\n\nexport function isCurrentDomain(domain : string) : boolean {\n    if (!isBrowser()) {\n        return false;\n    }\n\n    return (getDomain() === domain);\n}\n\nexport function isMockDomain(domain : string) : boolean {\n    return domain.indexOf(PROTOCOL.MOCK) === 0;\n}\n\nexport function normalizeMockUrl(url : string) : string {\n    if (!isMockDomain(getDomainFromUrl(url))) {\n        return url;\n    }\n\n    if (!__TEST__) {\n        throw new Error(`Mock urls not supported out of test mode`);\n    }\n\n    return url.replace(/^mock:\\/\\/[^/]+/, getActualDomain(window));\n}\n\nexport function closeWindow(win : CrossDomainWindowType) {\n    try {\n        win.close();\n    } catch (err) {\n        // pass\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/utils.js","/* @flow */\n\nexport function safeIndexOf<T>(collection : Array<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : Array<mixed>) {\n    // pass\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","/* @flow */\n\nimport { isWindow, isWindowClosed } from 'cross-domain-utils/src';\n\nimport { hasNativeWeakMap } from './native';\nimport { noop, safeIndexOf } from './util';\n\nexport class CrossDomainSafeWeakMap<K : Object, V : mixed> {\n\n    name : string\n    weakmap : ?WeakMap<K, V>\n    keys : Array<K>\n    values : Array<V>\n\n    constructor() {\n        // eslint-disable-next-line no-bitwise\n        this.name = `__weakmap_${ Math.random() * 1e9 >>> 0 }__`;\n\n        if (hasNativeWeakMap()) {\n            try {\n                this.weakmap = new WeakMap();\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this.keys  = [];\n        this.values = [];\n    }\n\n    _cleanupClosedWindows() {\n\n        let weakmap = this.weakmap;\n        let keys = this.keys;\n\n        for (let i = 0; i < keys.length; i++) {\n            let value = keys[i];\n\n            if (isWindow(value) && isWindowClosed(value)) {\n\n                if (weakmap) {\n                    try {\n                        weakmap.delete(value);\n                    } catch (err) {\n                        // pass\n                    }\n                }\n\n                keys.splice(i, 1);\n                this.values.splice(i, 1);\n\n                i -= 1;\n            }\n        }\n    }\n\n    isSafeToReadWrite(key : K) : boolean {\n\n        if (isWindow(key)) {\n            return false;\n        }\n\n        try {\n            noop(key && key.self);\n            noop(key && key[this.name]);\n        } catch (err) {\n            return false;\n        }\n\n        return true;\n    }\n\n    set(key : K, value : V) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.set(key, value);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                let name = this.name;\n                let entry = key[name];\n\n                if (entry && entry[0] === key) {\n                    entry[1] = value;\n                } else {\n                    Object.defineProperty(key, name, {\n                        value:    [ key, value ],\n                        writable: true\n                    });\n                }\n\n                return;\n\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        let keys = this.keys;\n        let values = this.values;\n        let index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            keys.push(key);\n            values.push(value);\n        } else {\n            values[index] = value;\n        }\n    }\n\n    get(key : K) : V | void {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return weakmap.get(key);\n                }\n                \n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                let entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return entry[1];\n                }\n\n                return;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        let keys = this.keys;\n        let index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            return;\n        }\n\n        return this.values[index];\n    }\n\n    delete(key : K) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.delete(key);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                let entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    entry[0] = entry[1] = undefined;\n                }\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        let keys = this.keys;\n        let index = safeIndexOf(keys, key);\n\n        if (index !== -1) {\n            keys.splice(index, 1);\n            this.values.splice(index, 1);\n        }\n    }\n\n    has(key : K) : boolean {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return true;\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                let entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return true;\n                }\n\n                return false;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        let index = safeIndexOf(this.keys, key);\n        return index !== -1;\n    }\n\n    getOrSet(key : K, getter : () => V) : V {\n        if (this.has(key)) {\n            // $FlowFixMe\n            return this.get(key);\n        }\n\n        let value = getter();\n        this.set(key, value);\n        return value;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/weakmap.js","/* @flow */\n\nexport function hasNativeWeakMap() : boolean {\n\n    if (typeof WeakMap === 'undefined') {\n        return false;\n    }\n\n    if (typeof Object.freeze === 'undefined') {\n        return false;\n    }\n\n    try {\n\n        let testWeakMap = new WeakMap();\n        let testKey = {};\n        let testValue = '__testvalue__';\n\n        Object.freeze(testKey);\n\n        testWeakMap.set(testKey, testValue);\n\n        if (testWeakMap.get(testKey) === testValue) {\n            return true;\n        }\n\n        return false;\n\n    } catch (err) {\n\n        return false;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/native.js","/* @flow */\n\nexport { CrossDomainSafeWeakMap as WeakMap } from './weakmap';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}